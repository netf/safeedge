// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_logs.sql

package generated

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
  organization_id,
  user_email,
  event_type,
  resource_type,
  resource_id,
  action,
  result,
  metadata,
  ip_address
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, timestamp, organization_id, user_email, event_type, resource_type, resource_id, action, result, metadata, ip_address
`

type CreateAuditLogParams struct {
	OrganizationID uuid.UUID   `json:"organization_id"`
	UserEmail      pgtype.Text `json:"user_email"`
	EventType      string      `json:"event_type"`
	ResourceType   string      `json:"resource_type"`
	ResourceID     string      `json:"resource_id"`
	Action         string      `json:"action"`
	Result         string      `json:"result"`
	Metadata       []byte      `json:"metadata"`
	IpAddress      *netip.Addr `json:"ip_address"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.OrganizationID,
		arg.UserEmail,
		arg.EventType,
		arg.ResourceType,
		arg.ResourceID,
		arg.Action,
		arg.Result,
		arg.Metadata,
		arg.IpAddress,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.OrganizationID,
		&i.UserEmail,
		&i.EventType,
		&i.ResourceType,
		&i.ResourceID,
		&i.Action,
		&i.Result,
		&i.Metadata,
		&i.IpAddress,
	)
	return i, err
}

const deleteOldAuditLogs = `-- name: DeleteOldAuditLogs :exec
DELETE FROM audit_logs
WHERE timestamp < NOW() - INTERVAL '90 days'
`

func (q *Queries) DeleteOldAuditLogs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldAuditLogs)
	return err
}

const getAuditLogsByResource = `-- name: GetAuditLogsByResource :many
SELECT id, timestamp, organization_id, user_email, event_type, resource_type, resource_id, action, result, metadata, ip_address FROM audit_logs
WHERE resource_type = $1 AND resource_id = $2
ORDER BY timestamp DESC
LIMIT $3
`

type GetAuditLogsByResourceParams struct {
	ResourceType string `json:"resource_type"`
	ResourceID   string `json:"resource_id"`
	Limit        int32  `json:"limit"`
}

func (q *Queries) GetAuditLogsByResource(ctx context.Context, arg GetAuditLogsByResourceParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByResource, arg.ResourceType, arg.ResourceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.OrganizationID,
			&i.UserEmail,
			&i.EventType,
			&i.ResourceType,
			&i.ResourceID,
			&i.Action,
			&i.Result,
			&i.Metadata,
			&i.IpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, timestamp, organization_id, user_email, event_type, resource_type, resource_id, action, result, metadata, ip_address FROM audit_logs
WHERE organization_id = $1
  AND ($2::timestamptz IS NULL OR timestamp >= $2)
  AND ($3::timestamptz IS NULL OR timestamp <= $3)
  AND ($4::text IS NULL OR event_type = $4)
ORDER BY timestamp DESC
LIMIT $5 OFFSET $6
`

type ListAuditLogsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Column2        time.Time `json:"column_2"`
	Column3        time.Time `json:"column_3"`
	Column4        string    `json:"column_4"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogs,
		arg.OrganizationID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.OrganizationID,
			&i.UserEmail,
			&i.EventType,
			&i.ResourceType,
			&i.ResourceID,
			&i.Action,
			&i.Result,
			&i.Metadata,
			&i.IpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
